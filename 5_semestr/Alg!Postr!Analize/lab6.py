#AVL tree (двоичное сбалансированное дерево)
 # Класс узла. По сравнению с общим деревом двоичного поиска, дерево AVL имеет атрибут высоты дерева, 
 # добавленный к узлу, что удобно для оценки того, сбалансировано ли оно, чтобы решить, следует ли выполнять корректировку.
class Node(object):
    def __init__(self, data, left=None, right=None):
        self.data = data # хранит данные об узле 
        self.left = left # ответвление влево
        self.right = right # ответвление вправо
        self.height = 0 # высота АВЛ деерва

#AVL_Tree класс
class AVL_Tree(object):
    
    # Инициация
    def __init__(self):
        self.root = None
    
    # Поиск в дереве
    def find(self, key):
        if not self.root:
            return -1
        else:
            return self.step_find(key, self.root) # Переход 
    # сама функция поиска в дереве
    def step_find(self, key, node):
        if not node: # проверка на пустой узел
            return None
        elif key < node.data: # Переход в левую ветку если значение меньше содержимого
            return self.step_find(key, node.left)
        elif key > node.data: # Или же переход в правую если значение больше чем данные которые хранятся в узле
            return self.step_find(key, node.right)
        else:# Используется для рекурсивного возврата результата вверх
            return node

    # Вывод высоты
    def height(self, node):
        if node is None:
            return -1
                 # В противном случае вернуть высоту узла напрямую
        else:
            return node.height
             
    def left_rotate(self, node):
        # k1 первая точка на левый дочерний узел узла
        k1 = node.left
            # Начать вращение. После вставки форма узла образует тройное соединение слева-слева-слева.(См. Рисунок за пределами блока кода выше,Слева, слева и слева здесь относятся к хранилищу2、3、4Узел(Не включено1))。
            # Вращение - это процесс подъема средних узлов тройного соединения, поэтому ключевым моментом является построение формы средних узлов.
            # Формирование новой формы в два этапа.
            # Первый шаг, релиз вот-вот поднимется(Посередине картинка3)Правый ребенок узла
            # Назначьте его самому верхнему узлу в исходных трех компаниях(Картина5)Левый ребенок, освободи правого ребенка.
        node.left = k1.right
            # Второй шаг - установить правый дочерний элемент среднего узла как самый верхний узел в исходных трех соединениях, и новая форма будет завершена
        k1.right = node
            # Измените высоту узла, на котором он расположен
        #node (верхний узел трех исходных компаний, соответствующий 5 на рисунке) отклонен.
            # Высота поддерева с корнем в узле равна большему значению его нового левого поддерева и исходного правого поддерева плюс1
        node.height = max(self.height(node.right), self.height(node.left)) + 1
            # Кk1(Исходный трехсвязный промежуточный узел, соответствующий на рисунке3)Подвернулся.
            # Высота поддерева с корнем k1 - это его исходное левое поддерево и новое правое поддерево(Дерево с корнем в узле)Большее значение плюс1
        k1.height = max(self.height(k1.left), node.height) + 1
            # Возврат к измененному корневому узлу поддерева, который является центральным узлом исходного трехсвязного узла
        return k1

    def right_rotate(self, node):
        # k1 эквивалентен указанному выше узлу 4 вне блока кода
        k1 = node.right
            # Начать вращение. После вставки форма узла представляет собой правое, правое и правое тройное соединение.(См. Диаграмму вне блока кода,Право, право, право, хранилище2、4、5Узел(Не включено6))。
            # Вращение - это процесс подъема средних узлов тройного соединения, поэтому ключевым моментом является построение формы средних узлов.
            # Формирование новой формы в два этапа.
            # Первый шаг, релиз вот-вот поднимется(Посередине картинка4)Левый дочерний элемент узла
            # Назначьте его самому верхнему узлу в исходных трех компаниях(Картина2)Правый ребенок, освободите левого ребенка.
        node.right = k1.left
            # Второй шаг - установить левый дочерний элемент среднего узла как самый верхний узел в исходных трех соединениях, и новая форма будет завершена
        k1.left = node
            # Измените высоту узла, на котором он расположен
        #node (верхний узел трех исходных компаний, соответствующий 2 на рисунке) отклонен.
        # Высота поддерева с корнем в узле равна большему значению его нового правого поддерева, а исходное левое поддерево плюс1
        node.height = max(self.height(node.right), self.height(node.left)) + 1
            # Кk1(Исходный трехсвязный промежуточный узел, соответствующий на рисунке4)Подвернулся.
            # Высота поддерева с корнем k1 - это его исходное правое поддерево и новое левое поддерево(Дерево с корнем в узле)Большее значение плюс1
        k1.height = max(self.height(k1.right), node.height) + 1
            # Вернуться к корневому узлу текущего поддерева, то есть k1
        return k1

    def left_right_rotate(self, node):
        if node != None:
            node.left = self.right_rotate(node.left)
            return self.left_rotate(node)
       

    def insert(self, key):
        # Если корень вообще не существует, значит такого дерева нет. Непосредственно использовать вставляемый элемент как корень дерева
        if not self.root:
            self.root = Node(key)
        else:
            self.root = self._insert(key, self.root)
    def _insert(self, key, node):
        # Рекурсивный последний шаг вставки.
        # Если узел отсутствует, это означает, что он достиг позиции, которую нужно вставить, и напрямую преобразовать ключ в узел и заполнить его.
        # Если это выполненоifЗаявление, узел ключа добавлен в дерево
        if node is None:
            node = Node(key)
                 # Если значение ключа меньше текущего указывающего узла, сузьте диапазон влево и используйте влево или влево, когда конфликт разрешен.
        elif key < node.data:
            #Recursion продвигается вниз по дереву, превращая его в меньшую проблему.
            node.left = self._insert(key, node.left)
            # После этого рекурсивного вызова мы наконец получаем правильную позицию, которую нужно вставить.
            # После вставки оцените и скорректируйте конфликты, которые не соответствуют правилам сбалансированного дерева.
            # Критерием определения необходимости корректировки является текущий ближайший узел поддерева.left,node.справа разница в высоте меньше чем2условия.
            # Recursion Каждый раз, когда вы возвращаетесь к предыдущему уровню, эта функция оценки будет вызываться для оценки уровня за слоем, пока не вернется к корневому узлу.
            # Пока правила просто где-то не соблюдаются(только что прибыл2), Исправить вовремя. Убедитесь, что максимальная разница высот никогда не превышает2
            # После следующего блока кода любое поддерево было оценено и преобразовано в соответствии с условиями сбалансированного двоичного дерева            
            if (self.height(node.left) - self.height(node.right)) == 2:
                #этоifУтверждение верно, должен быть конфликт, и он должен быть разрешен из узла.
                # При рекурсивном возврате результата я не знаю конкретное положение ключа относительно дочернего узла узла
                # Следовательно, сравните ключ с дочерними узлами узла, чтобы узнать, вставлен ли ключ слева или справа от дочернего узла текущего конфликтующего узла.
                # Если он меньше, чем левый дочерний элемент текущего узла конфликта, очевидно, что он разрешается с помощью left_left_rotate.
                if key < node.left.data:
                    node = self.left_rotate(node)
                    # В противном случае из-за начальногоifОператор определяет, что вставленное значение ключа меньше, чем текущий узел, поэтому возможно только то, что трехсвязный узел соответствует форме-left-right -, и соответствующая настройка может быть достигнута сначала влево, а затем вправо(Тройные узлы всегда могут не включать ключевые узлы)
                else:
                    node = self.right_rotate(node)
                # Полная двойственность. Когда ключ больше, чем текущие данные хранилища узла
        elif key > node.data:
            # При рекурсивном спуске он еще не вставлен. Сводится к подзадачам
            # Если он больше целевого узла, его следует вставить справа
            node.right = self._insert(key, node.right)
            # Следующее точно такое же, как и выше. Рекурсивная подзадача решена: следующие операторы выполняются, когда результаты проверяются рекурсивно вверх.
            if (self.height(node.right) - self.height(node.left)) == 2:
                if key > node.right.data:
                    node = self.right_rotate(node)
                else:
                    node = self.left_right_rotate(node)
        # Рекурсивное обновление высоты дерева
        node.height = max(self.height(node.right), self.height(node.left)) + 1
        # Вернуться к корневому узлу дерева после вставки. Он может отличаться от входного узла.
        return node
         # Предварительный обход полностью сбалансированного дерева точно такой же, как и общее двоичное дерево,Больше никогда.

        
    def delete(self,key):
        node = self.root
        last_node = self.root
        finding_node = self.find(key)
        while node.right != None and node.right != finding_node and node.left != None and node.left != finding_node:
            if key < node.data:
                last_node = self.root
                node = node.left
            elif key > node.data:
                last_node = self.root
                node = node.right
        
        if  node.left == finding_node:
            # if last_node != None:
            print("Предыдущая нода ", last_node.data)
            print("Текущая нода слева", node.left.data)
            now_node = node.left
            node.left = None
            if now_node.right != None:
                last_node.left = now_node.left
                changed_node = last_node.left
                changed_node.right = now_node.right
            elif now_node.left != None:
                last_node.right = now_node.right
                changed_node = last_node.right
                changed_node.left = now_node.left

        elif node.right == finding_node:
            print("Предыдущая нода ", last_node.data)
            print("Текущая нода справа", node.right.data)
            now_node = node.right
            node.right = None
            if now_node.right != None:
                last_node.right = now_node.right
                changed_node = last_node.right
                changed_node.left = now_node.left
            elif now_node.left != None:
                last_node.left = now_node.left
                changed_node = last_node.left
                changed_node.right = now_node.right
        else:
            return -1
    def tree_out(self, node):
        print("----"*40)
        print("\n")
        thislevel = [node]
        a = ' '*82
        while thislevel:
            nextlevel = list()
            a = a[:len(a)//2]
            for n in thislevel:
                if n is not None:
                    print(a+str(n.data)+a,end="")
                    if node.left:
                        nextlevel.append(n.left)
                    if node.right:
                        nextlevel.append(n.right)
                else:
                    print(a+" "+a,end="")
                thislevel = nextlevel
            print("\n\n")
        print("----"*40)
                


# Введите массив как элемент, в котором должен храниться каждый узел дерева
n = list(map(int,"2 1 3 4 5".split(" ")))
print(n)
 #   avl   Экземпляр
tree = AVL_Tree()
 # Вставить элементы списка в сбалансированное двоичное дерево один за другим
for i in range(len(n)):
    tree.insert(n[i])
# Сначала пройдемся по бинарному сбалансированному дереву
tree.tree_out(tree.root)
tree.delete(1)
tree.tree_out(tree.root)
tree.left_right_rotate
tree.tree_out(tree.root)